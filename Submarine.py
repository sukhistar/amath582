# Sukhjit Kaur
# AMATH 582 - Computational Methods for Data Analysis
# Homework 1 - Finding Submarines

# import libraries
import numpy as np
import plotly
import plotly.graph_objs as go
import matplotlib.pyplot as plt
import scipy
from scipy import ndimage
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D

# utility for clearing output of cell as loop runs in notebook
from IPython.display import clear_output

# Load data
data_path = '/Users/sukhjitkaur/Desktop/subdata.npy'
d = np.load(data_path)  # load subdata file

# Define variables
L = 10  # length of spatial domain
N = 64  # 64 grid points in each direction
T = 49  # number of measurements over the 24 hour period, taken every 30 minutes.

# Define grids
xx = np.linspace(-L, L, N + 1)  # spatial grid in x direction
x = xx[0:N]
y = x  # same grid in y direction
z = x  # same grid in z direction
xv, yv, zv = np.meshgrid(x, y, z)  # create 3D spatial meshgrid for plotting

k_grid = (2 * np.pi / (2 * L)) * np.linspace(-N / 2, N / 2 - 1,
                                             N)  # frequency grid for one coordinate, normalized with 2pi/2L
kx = k_grid
ky = kx  # frequency grid in y
kz = kx  # frequency grid in z
Kx, Ky, Kz = np.meshgrid(kx, ky, kz)

# Average the fourier transform of the signal, and determine the center freq.
for j in range(0, 49):
    d_reshaped = np.reshape(d[:, j], (N, N, N))
    fhat = (1/N)*np.real(np.fft.fftshift(np.fft.fftn(d_reshaped)))
d_norm = np.abs(d_reshaped)/np.abs(d_reshaped).max()
fhat_norm = np.abs(fhat) / np.abs(fhat).max()
center_freq = np.where(fhat_norm == np.max(fhat_norm))
center_freq_x = k_grid[center_freq[0]]
center_freq_y = k_grid[center_freq[1]]
center_freq_z = k_grid[center_freq[2]]
print(center_freq)
print("(x, y, z):", center_freq[0], center_freq[1], center_freq[2])
print(center_freq_x, center_freq_y, center_freq_z)

# Create Gaussian Filter using center freq as shift
def shift(index):
    shift = (index - 32) * 2 * L / 64
    return shift

def gaussian3d(kx, ky, kz, sig):  # G = e^-tau((Kx-kx)^2+(Ky-ky)^2=(Kz-kz)^2), tau = 1/2sig^2 gaussian in 3D
    kx_shift = shift(center_freq_x)
    ky_shift = shift(center_freq_y)
    kz_shift = shift(center_freq_z)

    tau = 1 / (2 * sig ** 2)
    gaussian = np.exp(-tau * ((kx - kx_shift) ** 2 + (ky - ky_shift) ** 2 + (kz - kz_shift) ** 2))

    val = gaussian
    return val

# Code for plotting isosurface

# Create the plot
#threshold = 0.5
#fig = go.Figure(data=go.Isosurface(
    #z=Kz.flatten(),
    #x=Kx.flatten(),
    #y=Ky.flatten(),
    #colorscale='Viridis',
    #value=fhat.flatten(),
    #isomin=threshold,
    #isomax=fhat.max(),
    #opacity=0.6,
#))

# Update the layout of the plot
#fig.update_layout(
    #title='',
    #scene=dict(
        #xaxis_title='X',
        #yaxis_title='Y',
        #zaxis_title='Z'
    #)
#)

#fig.show()

# plot slices

slice_idx = np.where(fhat_norm == np.max(fhat_norm))
slice_data = fhat_norm[:, :, slice_idx]

# Corresponding x and y coordinates for the slice
x_slice = Kx[:, :, slice_idx]
y_slice = Ky[:, :, slice_idx]

# Create a 2D heatmap of the slice
fig = go.Figure(data=go.Contour(
    x=x_slice.flatten(),
    y=y_slice.flatten(),
    z=slice_data.flatten(),  # Slice data
    colorscale='Viridis',
    contours=dict(showlabels=True) # Color scale for the heatmap
))

# Update the layout of the plot
fig.update_layout(
    title='Center-Frequency Generated by the Submarine',
    xaxis_title='kx',
    yaxis_title='ky'
)

fig.show()

# Apply Gaussian Filter to data
sigma = 5
xloc_filter = []
xloc_noisy = []
yloc_filter = []
yloc_noisy = []
zloc_filter = []
zloc_noisy = []
subloc_filter = []
subloc_noisy = []

# filter = np.ndarray((N,N,N,T));
# fhat_filtered = np.ndarray((N,N,N,T));
f_filtered = np.ndarray((N, N, N, T))

for j in range(0, 49):
    # reshape data and take fft and fftshift and scale
    d_reshaped = np.reshape(d[:, j], (N, N, N))
    d_norm = np.abs(d_reshaped) / np.abs(d_reshaped).max()
    fhat = (1 / N) * (np.fft.fftshift(np.fft.fftn(d_reshaped)))

    # apply the gaussian filter using the dominant frequency information
    filter = gaussian3d(kx, ky, kz, sigma)
    fhat_filtered = fhat * filter  # filter the data using gaussian filter in the frequency domain

    # take the inverse fft to obtain the filtered data
    f_filtered = np.fft.ifftn(np.fft.ifftshift(fhat_filtered))  # take the inverse fft to convert back to the signal domain
    f_filtered_norm = np.abs(f_filtered) / np.abs(f_filtered).max()  # normalize the data

    # locate the submarine with filtered data
    maxloc_filter = np.unravel_index(f_filtered_norm.argmax(), f_filtered_norm.shape)
    maxloc_noisy = np.unravel_index(d_norm.argmax(), d_norm.shape)
    subloc_filter.append(maxloc_filter)
    xloc_filter.append(maxloc_filter[0])
    yloc_filter.append(maxloc_filter[1])
    zloc_filter.append(maxloc_filter[2])
    subloc_noisy.append(maxloc_noisy[0])
    xloc_noisy.append(maxloc_noisy[0])
    yloc_noisy.append(maxloc_noisy[1])
    zloc_noisy.append(maxloc_noisy[2])

# Plot submarine location, unfiltered
fig = plt.figure('Submarine Path')
plt.suptitle('Submarine Path')
ax = fig.add_subplot(1,2,1)
ax.plot(xloc_noisy, yloc_noisy, 'k*', xloc_noisy, yloc_noisy, "k--", label ='Noisy')
ax.plot(xloc_filter, yloc_filter, 'r*', xloc_filter, yloc_filter, "r--", label ='Filtered')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('(a)')
ax.legend()
ax.tick_params(labelsize=5)

ax = fig.add_subplot(1,2,2, projection='3d')
ax.azim = 65
ax.elev = 20
ax.plot3D(xloc_noisy, yloc_noisy, zloc_noisy, color = 'purple', label = r'Noisy')
ax.scatter(xloc_noisy, yloc_noisy, zloc_noisy, s = 10, color = 'purple')
ax.plot3D(xloc_filter, yloc_filter, zloc_filter, color = 'blue', label = r'Filtered')
ax.scatter(xloc_filter, yloc_filter, zloc_filter, s = 10, color = 'blue')
ax.set_xlabel('x'); ax.set_ylabel('y'); ax.set_zlabel('z')
ax.set_title('(b)')
ax.legend()
ax.tick_params(labelsize=5)

plt.savefig('sublocation.pdf')
plt.show()

